"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const EventEmitter = require("eventemitter3");
const ws_1 = require("ws");
const uuidv4 = require("uuid/v4");
const MessageHandler_1 = require("./MessageHandler");
const MapLike_1 = require("./MapLike");
/**
 * JSON-RPC 2.0 WebSocket Server
 */
class Server extends EventEmitter {
    /**
     * Create a instance.
     * @param options
     * @param callback callback A listener for the `listening` event (ws).
     */
    constructor(options, callback) {
        super();
        this.sockets = new Map();
        this._lastPingAt = 0;
        this.options = Object.assign({
            pingTimeout: 5000,
            pingInterval: 25000,
            open: true,
            jsonrpcVersionCheck: 0 /* STRICT */,
            uws: false
        }, options);
        this._messageHandler = new MessageHandler_1.default(this.options);
        this._messageHandler.on("error_response", (socket, response) => {
            this.emit("error_response", socket, response);
            socket.emit("error_response", response);
        });
        this._messageHandler.on("notification_error", (socket, error) => {
            this.emit("notification_error", socket, error);
            socket.emit("notification_error", error);
        });
        if (this.options.open) {
            this.open(callback);
        }
    }
    get methods() { return this._messageHandler.methods; }
    /**
     * Create
     * @param callback callback A listener for the `listening` event (ws).
     */
    open(callback) {
        const self = this;
        if (this.wss) {
            throw new Error("`ws` has already been created");
        }
        if (this.options.uws) {
            this.wss = new (require("uws").Server)(this.options.wss, callback);
        }
        else {
            this.wss = new ws_1.Server(this.options.wss, callback);
        }
        this.wss.once("listening", function _onListeningWSS() {
            self.emit("listening");
        });
        this.wss.on("connection", function _onConnectionWSS(ws, req) {
            let socket = new Socket(ws);
            self.sockets.set(socket.id, socket);
            ws.once("close", function _onCloseWS() {
                self.sockets.delete(socket.id);
                socket.emit("close");
                socket.removeAllListeners();
                socket.ws = null;
                socket.rooms.clear();
                socket.data.clear();
                socket = null;
                ws.removeAllListeners();
                ws = null;
            });
            ws.on("message", function _onMessageWS(data) {
                self._messageHandler.handleMessage(socket, data)
                    .catch(function _onErrorHandleMessage(e) {
                    self.emit("error", e);
                });
            });
            ws.on("pong", function _onPongWS() {
                socket._pongAt = Date.now();
            });
            self.emit("connection", socket, req);
        });
        this.wss.on("error", function _onErrorWSS(e) {
            self.emit("error", e);
        });
        this._pingTimer = setInterval(this._ping.bind(this), this.options.pingInterval);
        return this;
    }
    /**
     * Closes the server and terminates all sockets.
     */
    async close() {
        clearInterval(this._pingTimer);
        for (const socket of this.sockets.values()) {
            socket.terminate();
        }
        await new Promise((resolve, reject) => {
            this.wss.close(err => {
                if (err) {
                    reject(err);
                }
                else {
                    resolve();
                }
            });
        });
        this.wss.removeAllListeners();
        delete this.wss;
        this.sockets.clear();
    }
    /**
     * Broadcasts a notification.
     * @param method The name of the method to be invoked.
     * @param params The parameters of the method.
     */
    broadcast(method, params) {
        const data = {
            jsonrpc: "2.0",
            method: method,
            params: params
        };
        const json = JSON.stringify(data);
        for (const socket of this.sockets.values()) {
            socket.send(json);
        }
    }
    /**
     * Broadcasts a notification to the room.
     * @param room The name of the room.
     * @param method The name of the method to be invoked.
     * @param params The parameters of the method.
     */
    notifyTo(room, method, params) {
        const data = {
            jsonrpc: "2.0",
            method: method,
            params: params
        };
        const json = JSON.stringify(data);
        for (const socket of this.sockets.values()) {
            if (socket.rooms.has(room) === true) {
                socket.send(json);
            }
        }
    }
    /**
     * Broadcasts a (raw) message to the room.
     * @param room The name of the room.
     * @param data (raw) message.
     */
    sendTo(room, data) {
        for (const socket of this.sockets.values()) {
            if (socket.rooms.has(room) === true) {
                socket.send(data);
            }
        }
    }
    /**
     * Get all sockets in the room.
     * @param room The name of the room.
     */
    in(room) {
        const sockets = new Map();
        for (const socket of this.sockets.values()) {
            if (socket.rooms.has(room) === true) {
                sockets.set(socket.id, socket);
            }
        }
        return sockets;
    }
    /**
     * Server is open or not
     */
    isOpen() {
        return this.wss !== undefined;
    }
    /**
     * Ping to all sockets.
     */
    _ping() {
        const deadline = this._lastPingAt + this.options.pingTimeout;
        for (const socket of this.sockets.values()) {
            if (socket._pongAt === -1 || socket._pongAt > deadline) {
                socket.terminate();
                continue;
            }
            socket._pongAt = -1;
            if (socket.isOpen()) {
                socket.ws.ping();
            }
        }
        this._lastPingAt = Date.now();
    }
}
exports.default = Server;
class Socket extends EventEmitter {
    constructor(ws) {
        super();
        this.ws = ws;
        this.id = uuidv4();
        this.rooms = new Set();
        /** custom data store */
        this.data = new MapLike_1.default();
        /** (internal using for heartbeat) */
        this._pongAt = 0;
    }
    /**
     * Sends a notification to the socket.
     * @param method The name of the method to be invoked.
     * @param params The parameters of the method.
     */
    notify(method, params) {
        const data = {
            jsonrpc: "2.0",
            method: method,
            params: params
        };
        this.send(JSON.stringify(data));
    }
    /**
     * Sends a (raw) message to the socket.
     * @param data (raw) message.
     * @param binary binary flag.
     */
    send(data, binary = false) {
        if (this.isOpen()) {
            this.ws.send(data, { binary });
        }
    }
    /**
     * Joins a room. You can join multiple rooms.
     * @param room The name of the room that we want to join.
     */
    joinTo(room) {
        if (this.rooms.has(room) === false) {
            this.rooms.add(room);
            return true;
        }
        return false;
    }
    /**
     * Leaves a room.
     * @param room The name of the room to leave.
     */
    leaveFrom(room) {
        if (this.rooms.has(room) === true) {
            this.rooms.delete(room);
            return true;
        }
        return false;
    }
    /**
     * Leaves all the rooms that we've joined.
     */
    leaveFromAll() {
        this.rooms.clear();
    }
    /**
     * Initiate a closing handshake.
     * @param code A numeric value indicating the status code explaining why the connection is being closed.
     * @param reason A human-readable string explaining why the connection is closing.
     */
    close(code, reason) {
        this.ws.close(code, reason);
    }
    /**
     * Forcibly close the connection.
     */
    terminate() {
        this.ws.terminate();
    }
    /**
     * Get the connection is open or not
     */
    isOpen() {
        return this.ws !== undefined && this.ws.readyState === ws_1.OPEN;
    }
}
exports.Socket = Socket;
//# sourceMappingURL=server.js.map