"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const common_1 = require("./common");
const EventEmitter = require("eventemitter3");
class MessageHandler extends EventEmitter {
    constructor(options) {
        super();
        this.options = options;
        this.methods = new Map();
    }
    async handleMessage(socket, data) {
        const calls = [];
        const responses = [];
        let isBinary = false;
        let isArray = false;
        if (data instanceof ArrayBuffer) {
            isBinary = true;
            data = Buffer.from(data).toString();
        }
        else if (data instanceof Buffer) {
            isBinary = true;
            data = data.toString();
        }
        else if (Array.isArray(data)) {
            isBinary = true;
            data = "[" + data.map(buf => buf.toString()).join(",") + "]";
        }
        try {
            const obj = JSON.parse(data);
            if (Array.isArray(obj)) {
                isArray = true;
                if (obj.length === 0) {
                    const res = {
                        jsonrpc: "2.0",
                        error: common_1.createError(-32600 /* InvalidRequest */, null, "Empty Array"),
                        id: null
                    };
                    socket.send(JSON.stringify(res), isBinary);
                    return;
                }
                calls.push(...obj);
            }
            else {
                calls.push(obj);
            }
        }
        catch (e) {
            const res = {
                jsonrpc: "2.0",
                error: common_1.createError(-32700 /* ParseError */, null, "Invalid JSON"),
                id: null
            };
            socket.send(JSON.stringify(res), isBinary);
            return;
        }
        for (const call of calls) {
            const res = await this._processCall(socket, call);
            if (res) {
                responses.push(res);
            }
        }
        if (responses.length === 0) {
            return;
        }
        socket.send(JSON.stringify(isArray ? responses : responses[0]), isBinary);
    }
    async _processCall(socket, call) {
        const reqId = call.id;
        const res = {
            jsonrpc: "2.0",
            id: reqId === undefined ? null : reqId
        };
        if (typeof call !== "object") {
            res.error = common_1.createError(-32600 /* InvalidRequest */);
            return res;
        }
        if (call.jsonrpc !== "2.0" && (this.options.jsonrpcVersionCheck === 0 /* STRICT */ ||
            (this.options.jsonrpcVersionCheck === 1 /* LOOSE */ && call.jsonrpc !== undefined))) {
            res.error = common_1.createError(-32600 /* InvalidRequest */, null, "Invalid JSON-RPC Version");
            return res;
        }
        if (common_1.isResponse(call)) {
            this.emit("response", socket, call);
            if (call.id !== null) {
                this.emit("method_response", socket, call);
                return;
            }
            if (!call.error) {
                res.error = common_1.createError(-32600 /* InvalidRequest */);
                return res;
            }
            this.emit("error_response", socket, call);
            if (call.error.code === -32700 /* ParseError */ || call.error.code === -32600 /* InvalidRequest */) {
                return;
            }
            this.emit("notification_error", socket, call.error);
            return;
        }
        if (!call.method) {
            res.error = common_1.createError(-32601 /* MethodNotFound */, null, "Method not specified");
            return res;
        }
        if (typeof call.method !== "string") {
            res.error = common_1.createError(-32600 /* InvalidRequest */, null, "Invalid type of method name");
            return res;
        }
        if ("params" in call && (typeof call.params !== "object" || call.params === null)) {
            res.error = common_1.createError(-32600 /* InvalidRequest */);
            return res;
        }
        if (this.methods.has(call.method) === false) {
            res.error = common_1.createError(-32601 /* MethodNotFound */);
            return res;
        }
        try {
            res.result = await this.methods.get(call.method)(socket, call.params) || null;
            if (reqId === undefined) {
                return;
            }
            return res;
        }
        catch (e) {
            if (reqId === undefined) {
                return;
            }
            if (e instanceof Error) {
                res.error = common_1.createError(-32000 /* ServerError */, e.name, e.message);
            }
            else {
                res.error = e;
            }
            return res;
        }
    }
}
exports.default = MessageHandler;
//# sourceMappingURL=MessageHandler.js.map