/// <reference types="ws" />
import WebSocket = require("isomorphic-ws");
import EventEmitter = require("eventemitter3");
import { Socket } from "./Socket";
import { Data } from "isomorphic-ws";
import { Error as RPCError, ErrorResponse } from "./common";
import { Options as MessageHandlerOptions } from "./MessageHandler";
/**
 * Client Config
 */
export interface Config extends MessageHandlerOptions, WebSocket.ClientOptions {
    reconnection: boolean;
    reconnectionAttempts: number;
    reconnectionDelay: number;
    reconnectionDelayMax: number;
    reconnectionJitter: number;
    methodCallTimeout: number;
    autoConnect: boolean;
    bufferSendingMessages: boolean;
    query: object;
    protocols: string | string[];
}
/**
 * Client Options
 */
export declare type Options = Partial<Config>;
export declare const ConfigDefaults: Config;
export default interface Client {
    on(event: "connecting", listener: (this: Client) => void): any;
    on(event: "connected", listener: (this: Client) => void): any;
    on(event: "disconnect", listener: (this: Client, code: number, reason: any) => void): any;
    on(event: "reconnecting", listener: (this: Client, attemps: number) => void): any;
    on(event: "reconnect_failed", listener: (this: Client) => void): any;
    on(event: "reconnect_error", listener: (this: Client, err: any) => void): any;
    on(event: "reconnected", listener: (this: Client, attemps: number) => void): any;
    on(event: "error_response", listener: (this: Client, response: ErrorResponse) => void): any;
    on(event: "notification_error", listener: (this: Client, error: RPCError) => void): any;
    on(event: "close", cb: (this: Client) => void): this;
    on(event: "error", listener: (this: Client, error: any) => void): any;
    on(event: "buffer_sending_error", listener: (this: Client, error: any) => void): any;
}
/**
 * JSON-RPC 2.0 Client
 */
export default class Client extends EventEmitter implements Socket {
    readonly uri: string;
    readonly config: Config;
    readonly sendingMessageBuffer: Data[];
    readonly methods: Map<string, (socket: Client, params: any) => any>;
    private _ws;
    private _backoff;
    private _reconnecting;
    private _messageHandler;
    private _responseHandlers;
    private _skipReconnection;
    private _currentRequestId;
    private _reconnectionSleepTimer;
    /**
     * Create an instance
     * @param uri The URI to connect.
     * @param options Options
     */
    constructor(uri: string, options?: Options);
    /**
     * Connect to the server
     */
    connect(): Promise<void>;
    /**
     * Disconnect the connection if it exists
     */
    disconnect(): Promise<void>;
    send(data: Data, binary?: boolean): void;
    clearSendingMessageBuffer(): void;
    notify(method: string, params?: object): void;
    call(method: string, params?: object): Promise<any>;
    isConnected(): boolean;
    private reconnect;
    private _handleMethodResponse;
    private _bufferSendingMessage;
    private _sendBufferedMessages;
}
