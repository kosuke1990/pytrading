/// <reference types="node" />
import * as http from "http";
import EventEmitter = require("eventemitter3");
import WebSocket = require("ws");
import { Server as WebSocketServer, ServerOptions as WSServerOptions } from "ws";
import { Error as RPCError, ErrorResponse } from "./common";
import { Socket as ISocket } from "./Socket";
import { Options as MessageHandlerOptions } from "./MessageHandler";
import MapLike from "./MapLike";
export interface Options extends MessageHandlerOptions {
    /**
     * how many ms without a pong packet to consider the connection closed
     */
    pingTimeout?: number;
    /**
     * how many ms before sending a new ping packet
     */
    pingInterval?: number;
    /**
     * call `#open()`
     */
    open?: boolean;
    /**
     * `ws` constructor's options.
     *  details: https://github.com/websockets/ws/blob/master/doc/ws.md
     */
    wss: WSServerOptions;
    /**
     * use `uws` (experimental)
     */
    uws?: boolean;
}
export default interface Server {
    on(event: "listening", cb: (this: Server) => void): this;
    on(event: "connection", cb: (this: Server, socket: Socket, req?: http.IncomingMessage) => void): this;
    on(event: "error", cb: (this: Server, error: Error) => void): this;
    on(event: "error_response", cb: (this: Server, response: ErrorResponse) => void): this;
    on(event: "notification_error", cb: (this: Server, error: RPCError) => void): this;
}
/**
 * JSON-RPC 2.0 WebSocket Server
 */
export default class Server extends EventEmitter {
    options: Options;
    wss: WebSocketServer;
    sockets: Map<string, Socket>;
    readonly methods: Map<string, (socket: Socket, params: any) => any>;
    private _messageHandler;
    private _pingTimer;
    private _lastPingAt;
    /**
     * Create a instance.
     * @param options
     * @param callback callback A listener for the `listening` event (ws).
     */
    constructor(options: Options, callback?: () => void);
    /**
     * Create
     * @param callback callback A listener for the `listening` event (ws).
     */
    open(callback?: () => void): this;
    /**
     * Closes the server and terminates all sockets.
     */
    close(): Promise<void>;
    /**
     * Broadcasts a notification.
     * @param method The name of the method to be invoked.
     * @param params The parameters of the method.
     */
    broadcast(method: string, params?: object): void;
    /**
     * Broadcasts a notification to the room.
     * @param room The name of the room.
     * @param method The name of the method to be invoked.
     * @param params The parameters of the method.
     */
    notifyTo(room: string, method: string, params?: object): void;
    /**
     * Broadcasts a (raw) message to the room.
     * @param room The name of the room.
     * @param data (raw) message.
     */
    sendTo(room: string, data: any): void;
    /**
     * Get all sockets in the room.
     * @param room The name of the room.
     */
    in(room: string): Map<string, Socket>;
    /**
     * Server is open or not
     */
    isOpen(): boolean;
    /**
     * Ping to all sockets.
     */
    private _ping;
}
/**
 * Socket of JSON-RPC 2.0 WebSocket Server
 */
export interface Socket extends ISocket {
    on(event: "close", cb: (this: Socket) => void): this;
    on(event: "notification_error", cb: (this: Socket, error: RPCError) => void): void;
    on(event: "error_response", cb: (this: Socket, response: ErrorResponse) => void): void;
}
export declare class Socket extends EventEmitter implements ISocket {
    ws: WebSocket;
    readonly id: string;
    readonly rooms: Set<string>;
    /** custom data store */
    readonly data: MapLike<any>;
    /** (internal using for heartbeat) */
    _pongAt: number;
    constructor(ws: WebSocket);
    /**
     * Sends a notification to the socket.
     * @param method The name of the method to be invoked.
     * @param params The parameters of the method.
     */
    notify(method: string, params?: any): void;
    /**
     * Sends a (raw) message to the socket.
     * @param data (raw) message.
     * @param binary binary flag.
     */
    send(data: any, binary?: boolean): void;
    /**
     * Joins a room. You can join multiple rooms.
     * @param room The name of the room that we want to join.
     */
    joinTo(room: string): boolean;
    /**
     * Leaves a room.
     * @param room The name of the room to leave.
     */
    leaveFrom(room: string): boolean;
    /**
     * Leaves all the rooms that we've joined.
     */
    leaveFromAll(): void;
    /**
     * Initiate a closing handshake.
     * @param code A numeric value indicating the status code explaining why the connection is being closed.
     * @param reason A human-readable string explaining why the connection is closing.
     */
    close(code?: number, reason?: string): void;
    /**
     * Forcibly close the connection.
     */
    terminate(): void;
    /**
     * Get the connection is open or not
     */
    isOpen(): boolean;
}
